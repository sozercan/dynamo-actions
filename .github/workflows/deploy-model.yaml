name: deploy-model

on:
  workflow_dispatch:
    inputs:
      runtime:
        description: "Model runtime (vllm | sglang)"
        type: choice
        options:
          - vllm
          - sglang
        default: vllm
        required: true
      deployment_type:
        description: "Template in deploy/ to render"
        type: choice
        options:
          - agg
          - agg_router
          - agg_logging
          - disagg
          - disagg_router
          - disagg_planner
          - disagg_multinode
        default: disagg
        required: true
      main_container_image:
        description: "Main container image for all components"
        default: nvcr.io/nvidia/ai-dynamo/vllm-runtime:0.5.0
        required: true
      model_name:
        description: "Model identifier passed to dynamo.vllm"
        default: Qwen/Qwen3-0.6B
        required: true
      replicas:
        description: >-
          JSON map of replica counts. Keys: frontend, decode, prefill, planner, prometheus.
          Example: {"frontend":1,"decode":1,"prefill":1,"planner":1,"prometheus":1}
        default: '{"frontend":1,"decode":1,"prefill":1,"planner":1,"prometheus":1}'
        required: false
      sglang_scaling:
        description: >-
          JSON for SGLang scaling: page_size,tp_size,dp_size,ep_size,decode_gpus,prefill_gpus,multinode_decode_node_count,multinode_prefill_node_count.
        default: '{"page_size":16,"tp_size":1,"dp_size":1,"ep_size":1,"decode_gpus":1,"prefill_gpus":1,"multinode_decode_node_count":1,"multinode_prefill_node_count":1}'
        required: false
      sglang_flags:
        description: >-
          JSON for boolean / misc flags: enable_dp_attention,trust_remote_code,skip_tokenizer_init,mem_fraction_static.
        default: '{"enable_dp_attention":false,"trust_remote_code":true,"skip_tokenizer_init":true,"mem_fraction_static":""}'
        required: false
      sglang_disagg:
        description: >-
          JSON for disaggregation params: disagg_transfer_backend,disagg_bootstrap_port.
        default: '{"disagg_transfer_backend":"nixl","disagg_bootstrap_port":30001}'
        required: false
      command_extras:
        description: >-
          JSON for extra command fragments: worker,frontend,planner,prometheus.
        default: '{"worker":"","frontend":"","planner":"","prometheus":""}'
        required: false

permissions: read-all

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event.inputs.runtime || 'vllm' }}-${{ github.event.inputs.deployment_type || 'manual' }}
  cancel-in-progress: true

env:
  NAMESPACE: dynamo-cloud

jobs:
  deploy:
    runs-on: self-hosted
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Parse configuration inputs
        id: parse
        env:
          RUNTIME: ${{ github.event.inputs.runtime }}
          REPLICAS_JSON: ${{ github.event.inputs.replicas }}
          SGLANG_SCALING_JSON: ${{ github.event.inputs.sglang_scaling }}
          SGLANG_FLAGS_JSON: ${{ github.event.inputs.sglang_flags }}
          SGLANG_DISAGG_JSON: ${{ github.event.inputs.sglang_disagg }}
          COMMAND_EXTRAS_JSON: ${{ github.event.inputs.command_extras }}
        shell: python
        run: |
          import os, json, sys

          def load(name, default):
              raw = os.environ.get(name, '').strip()
              if not raw:
                  raw = default
              try:
                  return json.loads(raw)
              except json.JSONDecodeError:
                  print(f"::warning::Invalid JSON for {name}; using defaults")
                  return json.loads(default)

          replicas = load('REPLICAS_JSON', '{"frontend":1,"decode":1,"prefill":1,"planner":1,"prometheus":1}')
          scaling = load('SGLANG_SCALING_JSON', '{"page_size":16,"tp_size":1,"dp_size":1,"ep_size":1,"decode_gpus":1,"prefill_gpus":1,"multinode_decode_node_count":1,"multinode_prefill_node_count":1}')
          flags = load('SGLANG_FLAGS_JSON', '{"enable_dp_attention":false,"trust_remote_code":true,"skip_tokenizer_init":true,"mem_fraction_static":""}')
          disagg = load('SGLANG_DISAGG_JSON', '{"disagg_transfer_backend":"nixl","disagg_bootstrap_port":30001}')
          extras = load('COMMAND_EXTRAS_JSON', '{"worker":"","frontend":"","planner":"","prometheus":""}')

          # Export replica env vars
          mappings = {
              'FRONTEND_REPLICAS': replicas.get('frontend', 1),
              'DECODE_REPLICAS': replicas.get('decode', 1),
              'PREFILL_REPLICAS': replicas.get('prefill', 1),
              'PLANNER_REPLICAS': replicas.get('planner', 1),
              'PROMETHEUS_REPLICAS': replicas.get('prometheus', 1),
              'PAGE_SIZE': scaling.get('page_size', 16),
              'TP_SIZE': scaling.get('tp_size', 1),
              'DP_SIZE': scaling.get('dp_size', 1),
              'EP_SIZE': scaling.get('ep_size', 1),
              'DECODE_GPUS': scaling.get('decode_gpus', 1),
              'PREFILL_GPUS': scaling.get('prefill_gpus', 1),
              'MULTINODE_DECODE_NODE_COUNT': scaling.get('multinode_decode_node_count', 1),
              'MULTINODE_PREFILL_NODE_COUNT': scaling.get('multinode_prefill_node_count', 1),
              'ENABLE_DP_ATTENTION': str(flags.get('enable_dp_attention', False)).lower(),
              'TRUST_REMOTE_CODE': str(flags.get('trust_remote_code', True)).lower(),
              'SKIP_TOKENIZER_INIT': str(flags.get('skip_tokenizer_init', True)).lower(),
              'MEM_FRACTION_STATIC': flags.get('mem_fraction_static', ''),
              'DISAGG_TRANSFER_BACKEND': disagg.get('disagg_transfer_backend', 'nixl'),
              'DISAGG_BOOTSTRAP_PORT': disagg.get('disagg_bootstrap_port', 30001),
              'WORKER_COMMAND_EXTRA': extras.get('worker', ''),
              'FRONTEND_COMMAND_EXTRA': extras.get('frontend', ''),
              'PLANNER_COMMAND_EXTRA': extras.get('planner', ''),
              'PROMETHEUS_COMMAND_EXTRA': extras.get('prometheus', ''),
          }

          with open(os.environ['GITHUB_ENV'], 'a', encoding='utf-8') as fh:
              for k, v in mappings.items():
                  fh.write(f"{k}={v}\n")

          # Echo a summary
          print("Parsed replicas:", replicas)
          if os.environ.get('RUNTIME') == 'sglang':
              print("Parsed sglang scaling:", scaling)
              print("Parsed sglang flags:", flags)
              print("Parsed sglang disagg:", disagg)
              print("Parsed command extras:", extras)

      - name: Build sglang commands (if runtime=sglang)
        id: build-sglang
        env:
          RUNTIME: ${{ github.event.inputs.runtime }}
          DEPLOYMENT_TYPE: ${{ github.event.inputs.deployment_type }}
          MODEL: ${{ github.event.inputs.model_name }}
          PAGE_SIZE: ${{ env.PAGE_SIZE }}
          TP_SIZE: ${{ env.TP_SIZE }}
          DP_SIZE: ${{ env.DP_SIZE }}
          EP_SIZE: ${{ env.EP_SIZE }}
          ENABLE_DP_ATTENTION: ${{ env.ENABLE_DP_ATTENTION }}
          TRUST_REMOTE_CODE: ${{ env.TRUST_REMOTE_CODE }}
          SKIP_TOKENIZER_INIT: ${{ env.SKIP_TOKENIZER_INIT }}
          DISAGG_TRANSFER_BACKEND: ${{ env.DISAGG_TRANSFER_BACKEND }}
          DISAGG_BOOTSTRAP_PORT: ${{ env.DISAGG_BOOTSTRAP_PORT }}
          MEM_FRACTION_STATIC: ${{ env.MEM_FRACTION_STATIC }}
          WORKER_COMMAND_EXTRA: ${{ env.WORKER_COMMAND_EXTRA }}
          FRONTEND_COMMAND_EXTRA: ${{ env.FRONTEND_COMMAND_EXTRA }}
          PLANNER_COMMAND_EXTRA: ${{ env.PLANNER_COMMAND_EXTRA }}
          PROMETHEUS_COMMAND_EXTRA: ${{ env.PROMETHEUS_COMMAND_EXTRA }}
        run: |
          set -euo pipefail
          if [ "$RUNTIME" != "sglang" ]; then
            echo "runtime is $RUNTIME; skipping sglang command build";
            exit 0
          fi

            # Base command
          BASE="python3 -m dynamo.sglang --model-path $MODEL --served-model-name $MODEL --page-size ${PAGE_SIZE} --tp ${TP_SIZE}"
          if [ "${DP_SIZE}" != "1" ]; then BASE+=" --dp ${DP_SIZE}"; fi
          if [ "${EP_SIZE}" != "1" ]; then BASE+=" --ep-size ${EP_SIZE}"; fi
          # Boolean flags
          [ "${ENABLE_DP_ATTENTION}" = "true" ] && BASE+=" --enable-dp-attention"
          [ "${TRUST_REMOTE_CODE}" = "true" ] && BASE+=" --trust-remote-code"
            # Some users may want to disable skip-tokenizer-init, so only add when true
          [ "${SKIP_TOKENIZER_INIT}" = "true" ] && BASE+=" --skip-tokenizer-init"
          if [ -n "${MEM_FRACTION_STATIC}" ]; then BASE+=" --mem-fraction-static ${MEM_FRACTION_STATIC}"; fi

          if [[ "$DEPLOYMENT_TYPE" == disagg* ]]; then
            DECODE_ROLE_FLAGS="--disaggregation-mode decode --disaggregation-transfer-backend ${DISAGG_TRANSFER_BACKEND} --disaggregation-bootstrap-port ${DISAGG_BOOTSTRAP_PORT}"
            PREFILL_ROLE_FLAGS="--disaggregation-mode prefill --disaggregation-transfer-backend ${DISAGG_TRANSFER_BACKEND} --disaggregation-bootstrap-port ${DISAGG_BOOTSTRAP_PORT}"
          else
            DECODE_ROLE_FLAGS=""
            PREFILL_ROLE_FLAGS=""
          fi

          FRONTEND_COMMAND="exec ${BASE} ${FRONTEND_COMMAND_EXTRA}";
          DECODE_COMMAND="exec ${BASE} ${DECODE_ROLE_FLAGS} ${WORKER_COMMAND_EXTRA}";
          PREFILL_COMMAND="exec ${BASE} ${PREFILL_ROLE_FLAGS} ${WORKER_COMMAND_EXTRA}";
          PLANNER_COMMAND="exec python3 -m planner_sla --environment=kubernetes --backend=sglang --adjustment-interval=60 --profile-results-dir=/data/profiling_results ${PLANNER_COMMAND_EXTRA}";
          PROMETHEUS_COMMAND="python3 -m dynamo.planner.prometheus ${PROMETHEUS_COMMAND_EXTRA}";

          {
            echo "FRONTEND_COMMAND=${FRONTEND_COMMAND}";
            echo "DECODE_COMMAND=${DECODE_COMMAND}";
            echo "PREFILL_COMMAND=${PREFILL_COMMAND}";
            echo "PLANNER_COMMAND=${PLANNER_COMMAND}";
            echo "PROMETHEUS_COMMAND=${PROMETHEUS_COMMAND}";
          } >> "$GITHUB_ENV"

      - name: Render manifest from template
        id: render
        env:
          RUNTIME: ${{ github.event.inputs.runtime }}
          DEPLOYMENT_TYPE: ${{ github.event.inputs.deployment_type }}
          MAIN_CONTAINER_IMAGE: ${{ github.event.inputs.main_container_image }}
          MODEL: ${{ github.event.inputs.model_name }}
          FRONTEND_REPLICAS: ${{ env.FRONTEND_REPLICAS }}
          DECODE_REPLICAS: ${{ env.DECODE_REPLICAS }}
          PREFILL_REPLICAS: ${{ env.PREFILL_REPLICAS }}
          PLANNER_REPLICAS: ${{ env.PLANNER_REPLICAS }}
          PROMETHEUS_REPLICAS: ${{ env.PROMETHEUS_REPLICAS }}
          # sglang extras for envsubst (even if not used by vllm templates)
          PAGE_SIZE: ${{ env.PAGE_SIZE }}
          TP_SIZE: ${{ env.TP_SIZE }}
          DP_SIZE: ${{ env.DP_SIZE }}
          EP_SIZE: ${{ env.EP_SIZE }}
          DECODE_GPUS: ${{ env.DECODE_GPUS }}
          PREFILL_GPUS: ${{ env.PREFILL_GPUS }}
          ENABLE_DP_ATTENTION: ${{ env.ENABLE_DP_ATTENTION }}
          TRUST_REMOTE_CODE: ${{ env.TRUST_REMOTE_CODE }}
          SKIP_TOKENIZER_INIT: ${{ env.SKIP_TOKENIZER_INIT }}
          DISAGG_TRANSFER_BACKEND: ${{ env.DISAGG_TRANSFER_BACKEND }}
          DISAGG_BOOTSTRAP_PORT: ${{ env.DISAGG_BOOTSTRAP_PORT }}
          MEM_FRACTION_STATIC: ${{ env.MEM_FRACTION_STATIC }}
          MULTINODE_DECODE_NODE_COUNT: ${{ env.MULTINODE_DECODE_NODE_COUNT }}
          MULTINODE_PREFILL_NODE_COUNT: ${{ env.MULTINODE_PREFILL_NODE_COUNT }}
          FRONTEND_COMMAND: ${{ env.FRONTEND_COMMAND }}
          DECODE_COMMAND: ${{ env.DECODE_COMMAND }}
          PREFILL_COMMAND: ${{ env.PREFILL_COMMAND }}
          PLANNER_COMMAND: ${{ env.PLANNER_COMMAND }}
          PROMETHEUS_COMMAND: ${{ env.PROMETHEUS_COMMAND }}
        run: |
          set -euo pipefail
          # Determine template path based on runtime
          TEMPLATE="deploy/${RUNTIME}/${DEPLOYMENT_TYPE}.yaml"
          if [ ! -f "$TEMPLATE" ]; then
            echo "Unsupported deployment combination runtime=${RUNTIME} type=${DEPLOYMENT_TYPE}" >&2
            echo "Available runtimes & templates:" >&2
            find deploy -maxdepth 2 -name '*.yaml' >&2
            exit 1
          fi

          mkdir -p rendered
          MANIFEST="rendered/${DEPLOYMENT_TYPE}.yaml"
          envsubst < "$TEMPLATE" > "$MANIFEST"
          echo "manifest_path=$MANIFEST" >> "$GITHUB_OUTPUT"

      - name: Override replica counts
        env:
          MANIFEST: ${{ steps.render.outputs.manifest_path }}
          FRONTEND_REPLICAS: ${{ env.FRONTEND_REPLICAS }}
          DECODE_REPLICAS: ${{ env.DECODE_REPLICAS }}
          PREFILL_REPLICAS: ${{ env.PREFILL_REPLICAS }}
          PLANNER_REPLICAS: ${{ env.PLANNER_REPLICAS }}
          PROMETHEUS_REPLICAS: ${{ env.PROMETHEUS_REPLICAS }}
        shell: python
        run: |
          import os
          from pathlib import Path

          path = Path(os.environ["MANIFEST"])
          lines = path.read_text(encoding="utf-8").splitlines()
          mapping = {
              "Frontend": "FRONTEND_REPLICAS",
              "VllmDecodeWorker": "DECODE_REPLICAS",
              "VllmPrefillWorker": "PREFILL_REPLICAS",
              "decode": "DECODE_REPLICAS",
              "prefill": "PREFILL_REPLICAS",
              "Planner": "PLANNER_REPLICAS",
              "Prometheus": "PROMETHEUS_REPLICAS",
          }

          current_service = None
          for idx, line in enumerate(lines):
              stripped = line.strip()
              indent = len(line) - len(line.lstrip(" "))

              if stripped.endswith(":") and indent == 4:
                  service_name = stripped[:-1]
                  current_service = service_name if service_name in mapping else None
                  continue

              if current_service and stripped.startswith("replicas:"):
                  env_key = mapping[current_service]
                  raw_value = os.getenv(env_key, "").strip()
                  if raw_value:
                      try:
                          replicas = int(raw_value)
                      except ValueError as exc:
                          raise SystemExit(
                              f"Invalid integer for {env_key}: {raw_value}"
                          ) from exc

                      comment = ""
                      if "#" in line:
                          hash_index = line.index("#")
                          comment = " " + line[hash_index:].rstrip()
                          prefix = line[:hash_index]
                      else:
                          prefix = line

                      prefix = prefix.split("replicas:")[0]
                      lines[idx] = f"{prefix}replicas: {replicas}{comment}".rstrip()
                  current_service = None

          path.write_text("\n".join(lines) + "\n", encoding="utf-8")
          print(path.read_text(encoding="utf-8"), end="")

      - name: Deploy to cluster
        run: |
          set -euo pipefail
          kubectl apply -f "${{ steps.render.outputs.manifest_path }}" -n ${NAMESPACE}

      - name: Validate deployment
        run: |
          set -euo pipefail
          kubectl get -f "${{ steps.render.outputs.manifest_path }}" -o name -n ${NAMESPACE}

      - name: Smoke test frontend API
        env:
          MODEL_NAME: ${{ github.event.inputs.model_name }}
        run: |
          set -euo pipefail

          echo "Locating frontend service via label selector..."
          FRONTEND_SVC=$(kubectl get svc -n ${NAMESPACE} -l 'nvidia.com/dynamo-component-type=frontend' -o jsonpath='{.items[0].metadata.name}') || true
          if [ -z "${FRONTEND_SVC}" ]; then
            echo "::error::No service found with label nvidia.com/dynamo-component-type=frontend in namespace ${NAMESPACE}" >&2
            kubectl get svc -n ${NAMESPACE} -l 'nvidia.com/dynamo-component-type=frontend' || true
            exit 1
          fi
          echo "Found service: ${FRONTEND_SVC}"

          echo "Waiting for frontend pods to become Ready..."
          # Wait for at least one ready pod (timeout 5m)
          if ! kubectl wait --for=condition=Ready pod -l nvidia.com/dynamo-component-type=frontend -n ${NAMESPACE} --timeout=300s; then
            echo "::error::Frontend pods did not become ready in time" >&2
            kubectl get pods -n ${NAMESPACE} -l nvidia.com/dynamo-component-type=frontend -o wide || true
            exit 1
          fi

          # Start port-forward in background
          echo "Starting port-forward to ${FRONTEND_SVC}..."
          kubectl port-forward svc/${FRONTEND_SVC} 8000:8000 -n ${NAMESPACE} >/tmp/port-forward.log 2>&1 &
          PF_PID=$!
          echo "Port-forward PID: $PF_PID"
          # Ensure cleanup
          trap 'echo "Stopping port-forward"; kill $PF_PID 2>/dev/null || true' EXIT

          # Wait for port-forward to establish
          attempt=0
          until curl -sf http://localhost:8000/v1/models >/dev/null 2>&1; do
            attempt=$((attempt+1))
            if [ $attempt -gt 30 ]; then
              echo "::error::/v1/models endpoint not responding after $attempt attempts" >&2
              echo "Port-forward logs:" >&2
              sed -e 's/^/PF: /' /tmp/port-forward.log || true
              exit 1
            fi
            sleep 2
          done

          echo "Fetching model list..."
          MODELS_JSON=$(curl -sSf http://localhost:8000/v1/models || true)
          echo "Models response: ${MODELS_JSON}" | sed 's/^/API: /'

          echo "Sending test chat completion request..."
          # Build JSON payload (MODEL_NAME already an env var; avoid heredoc to keep YAML parser happy)
          CHAT_REQ_EVAL=$(printf '{"model":"%s","messages":[{"role":"user","content":"Hello!"}],"max_tokens":20}' "${MODEL_NAME}")
          CHAT_RESP_HTTP=$(mktemp)
          HTTP_CODE=$(echo "$CHAT_REQ_EVAL" | curl -s -o "$CHAT_RESP_HTTP" -w '%{http_code}' -H 'Content-Type: application/json' http://localhost:8000/v1/chat/completions || true)

          echo "HTTP status: $HTTP_CODE"
            # Show response (truncate if huge)
          echo "Response body:"; sed -e 's/^/API: /' "$CHAT_RESP_HTTP" | head -c 5000

          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 400 ]; then
            echo "::error::Chat completion request failed (status $HTTP_CODE)" >&2
            exit 1
          fi

          echo "Smoke test succeeded."

      - name: Upload manifest artifact
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: rendered-manifest
          path: ${{ steps.render.outputs.manifest_path }}
